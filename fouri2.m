function eye = fouri2(trials,direction,sample_rate,period)
% fouri - fourier analysis of eye trace data to estimate gain and lag of
% participant eye motion. Eye traces are broken into fast and slow
% components. The fast components are the saccades. Right now saccade tags
% generated by the eyelink are used. We plan to write our own saccade
% identification routines.
% Data is prepared by first converting from .edf to asc using the GUI
% converter from SR Research. Then our script process_all_asc_data is run
% to preprocess and convert the asc data to .mat files.
%
% this was collewijn with ploting and some other stuff removed
% TODO take out code that is common to targfit.m or merge 
% TODO upsample target position to eye position sample rate to fix gain and
% phase measures.
% load('/Users/schizophrenia/Dropbox/eyetracks/collewijn/testdata/neg5phase1gain.mat')

numTrials = size(trials,2);
for i=1:numTrials
    
    %     figure(i)
    numSac_L=size(trials(i).sac_L,1); % FIXME is it ok to create this dummy saccade if no saccades present?
    if numSac_L > 0
    else
        trials(i).sac_L = [0 0 0 0 0 0 0 0 0]; %#ok<*AGROW>
    end
    numSac_R=size(trials(i).sac_R,1); 
    if numSac_R > 0
    else
        trials(i).sac_R = [0 0 0 0 0 0 0 0 0];
    end
    
    %% identify saccades,  may only be tracking right eye
    % eye tracker does not always give same number of saccades in both eyes
    if numSac_L == 0
        trials(i).sac = trials(i).sac_R;
    else
        trials(i).sac = trials(i).sac_L;
    end
    
    
    %% decomp into fast and slow plot 1 
    switch direction % TODO !! need to revise all code to do 2D analysis
        case 'Horizontal'
            eye_vel = [trials(i).eye(1,2) ; diff( trials(i).eye(:,2))]; % FIXME move the diff below case statement
            target_pos = trials(i).target(:,2);
        case 'Vertical'
            eye_vel = [trials(i).eye(1,3) ; diff( trials(i).eye(:,3))];
            target_pos = trials(i).target(:,3);
    end
    eye_vel(isnan(eye_vel))=0; %  fix missing data... FIXME people saccade during blinks!
    
    % TODO add our own saccade detection alg.
    % from eyelink 1000 manual pg. 86:
    % A velocity threshold of 22 degrees per second allows detection of 
    % saccades as small as 0.3°, ideal for smooth pursuit and psychophysical 
    % research. A conservative threshold of 30°/sec is better for reading 
    % and cognitive research, shortening saccades and lengthening fixation 
    % durations. The larger threshold also reduces the number of microsaccades 
    % detected, decreasing the number of short fixations (less than 100 msec 
    % in duration) in the data. Some short fixations (2% to 3% of total 
    % fixations) can be expected, and most researchers simply discard these.
    sacc_on = 1 + trials(i).sac(:,1)/(1000/sample_rate); % converts time to index /2 for 500Hz /4 for 250Hz
    sacc_off = 1 + trials(i).sac(:,2)/(1000/sample_rate);
    
    % get rid of saccades before stimulus onset
    sacc_on(sacc_on<1) = 1; % FIXME just delete the saccades move this code up before the lines above
    sacc_off(sacc_off<2) = 2;
    
    eye_slow = ones(size(eye_vel)); % tag with ones where not saccading and zero where we are saccading
    for sacc_idx = 1:length(sacc_on)
        eye_slow(sacc_on(sacc_idx):sacc_off(sacc_idx)) = 0;
    end
    slow_eye_vel = eye_vel.*eye_slow;
    slow_eye_pos = cumsum(slow_eye_vel);
    eye_pos = cumsum(eye_vel);
    eye_time = trials(i).eye(:,1)/1000; % convert to seconds
    target_time = trials(i).target(:,1)/1000;

    % init guesses: amp, phase, freq, offset
    % upsample target motion
    statopts = [];
    amp_guess = (max(target_pos) - min(target_pos)); % FIXME - should amp be divide by 2?
    offset_guess = (max(target_pos) + min(target_pos))/2;
    stimFreq = 1/sscanf(period,'%f');
    B0 = [ amp_guess, 0, 1/sscanf(period,'%f'),offset_guess]; % initial guesses
    Btarg = nlinfit(target_time,target_pos,@mysin,B0,statopts); % fitted parameters
    target_fit_pos = mysin(Btarg,eye_time);
    
    %% detrend
    detrend_data = true;
    if detrend_data
        slow_eye_pos = detrend(slow_eye_pos); % some times pursue better in one direction
        eye_pos = detrend(eye_pos);
        target_fit_pos = detrend(target_fit_pos); % why would we need to detrend the target pos?
    end
    
    %% zero pad and window the data
    L = length(eye_pos);
    Z = zeros(L,1);
    
    eye_pos = eye_pos .* hamming(length(eye_pos));
    slow_eye_pos = slow_eye_pos .* hamming(length(eye_pos));
    target_fit_pos = target_fit_pos .* hamming(length(eye_pos));
    
    eye_pos = [Z; eye_pos; Z];
    slow_eye_pos = [Z; slow_eye_pos; Z];
    target_fit_pos = [Z; target_fit_pos; Z];
    eye_time = [eye_time - eye_time(end); eye_time; eye_time + eye_time(end)];
    L = length(eye_pos);
    
    %% fourier amplitude
    %     subplot(2,2,3)
    Fs = sample_rate  ; % sample rate Hz
    Fs_stim = 120 ; % monitor refresh freq Hz
    
    Yeye  = fft(eye_pos,L)/L;
    Ytarg = fft(target_fit_pos,L)/L;
    Yslow = fft(slow_eye_pos,L)/L;
    
    f = Fs/2*linspace(0,1,L/2+1);
    Yeye = Yeye(1:L/2+1);
    Ytarg = Ytarg(1:L/2+1);
    Yslow = Yslow(1:L/2+1);
    
    eye_amp = 2*abs(Yeye); % calculate amplitude at freq
    targ_amp = 2*abs(Ytarg);
    slow_eye_amp = 2*abs(Yslow);
    
    %% calculate phase FIXME the target phase is subtracted out improperly freq do not quite line up
    eye_phase = angle(Yeye);
    targ_phase = angle(Ytarg);
    slow_eye_phase = angle(Yslow);
    eye_phase = rad2deg(eye_phase - targ_phase);
    slow_eye_phase = rad2deg(slow_eye_phase - targ_phase);
    
%     slow_eye_phase(slow_eye_phase>6) =  slow_eye_phase(slow_eye_phase>6)-2*pi; % get rid of wrap.
%     eye_phase(eye_phase>6) =  eye_phase(eye_phase>6)-2*pi;
    
    %% calculate gain
    eye_gain = eye_amp(1:length(targ_amp))./targ_amp;
    slow_eye_gain = slow_eye_amp(1:length(targ_amp))./targ_amp;
    
    fRightIdx = find(f>stimFreq,1,'first');
    fLeftIdx = find(stimFreq>=f,1,'last');
    
    eye(i).gain = eye_gain(fRightIdx);
    eye(i).slow.gain = slow_eye_gain(fRightIdx);
    eye(i).phase = eye_phase(fRightIdx);
    eye(i).slow.phase = slow_eye_phase(fRightIdx);
    eye(i).freq = f(fRightIdx);
    
    %% plot results
%     subplot(2,1,1)
%     plot(eye_time,target_fit_pos,':',eye_time,eye_pos)
%     
%     subplot(2,1,2)
%     plot(f,targ_amp,':',f,eye_amp,f,eye_phase,[1 1]*f(fRightIdx),[-10 20])
%     xlim([0 2*stimFreq])
    
end

%% function to fit
% init guesses: 1 amp, 2 phase, 3 freq, 4 offset
function yhat = mysin(B,X) % TODO add other predictors into model like turnarounds and extra cos for pseudo random

yhat = B(4) + B(1) * cos( B(2) +  2*pi * B(3) * X);

return

